package az.azreco.azrecoassistant.assistant

import android.annotation.SuppressLint
import android.util.Log
import androidx.lifecycle.MutableLiveData
import az.azreco.azrecoassistant.assistant.player.AudioPlayer
import az.azreco.azrecoassistant.assistant.azreco.SpeechRecognizer
import az.azreco.azrecoassistant.assistant.azreco.TextToSpeech
import az.azreco.azrecoassistant.assistant.azreco.TextToSpeechModel
import az.azreco.azrecoassistant.assistant.player.ExoPlayer
import az.azreco.azrecoassistant.constants.Audio
import kotlinx.coroutines.*
import java.io.ByteArrayOutputStream

class Assistant(
    private val speechRecognizer: SpeechRecognizer,
    private val textToSpeech: TextToSpeech,
    private val exoPlayer: ExoPlayer,
    private val audioPlayer: AudioPlayer
) {
    private val TAG = "Assistant"

    val isProcessing = MutableLiveData<Boolean>()


    // SPEECH TO TEXT
    suspend fun listen(silence: Int = 3, keyWords: String) = coroutineScope {
        val job = launch { speechRecognizer.listen(silence = silence, keyWords = keyWords) }
        job.join()
        playAsync(audioFile = Audio.signalStop)
    }

    suspend fun speechRecognize(silence: Int = 3) =
        speechRecognizer.speechRecognize(silence = silence)

    suspend fun keywordSpotting(silence: Int = 5, keyWords: String) =
        speechRecognizer.keywordSpotting(silence = silence, keyWords = keyWords)


    // recursive function, works until KWS result won't be empty or counter >= limit
    suspend fun reKeywordSpotting(
        keyWords: String,
        limit: Int = 5,
        startLambda: () -> Unit,
        endLambda: suspend (String) -> Unit
    ) = coroutineScope {
        var counter = 0
        break_input@ do {
            counter += 1
            startLambda() // callback listening
            playAsync(audioFile = Audio.signalStart)
            val kWord = keywordSpotting(keyWords = keyWords, silence = 4)
            if (kWord.isNotEmpty()) endLambda(kWord)
            else if (counter >= limit) {
                Log.d(TAG, "counter >= limit")
                playAsync(audioFile = Audio.signalStop)
                break@break_input
            } else if (kWord.isEmpty()) playSync(audioFile = Audio.repeats)

        } while (kWord.isEmpty())
    }

    // TEXT TO SPEECH
    /**
     * play single text by TextToSpeech
     */
    @SuppressLint("NewApi")
    suspend fun speak(text: String, voiceId: String = "") =
        textToSpeech.speak(text = text, voiceId = voiceId)

    /**
     * play ByteArrayOutputStream, generated by TextToSpeech
     */
    @SuppressLint("NewApi")
    suspend fun speakByteStream(baos: ByteArrayOutputStream) =
        textToSpeech.speakByteStream(baos = baos)

    /**
     * synthesize list of texts, returns list of generated ByteArrayOutputStream. for play use speakByteStream
     */
    @SuppressLint("NewApi")
    suspend fun synthesizeMultiple(
        texts: List<String>,
        voiceId: String = ""
    ): List<TextToSpeechModel> = textToSpeech.synthesizeMultiple(texts = texts, voiceId = voiceId)

    // EXO PLAYER
    /**
     * plays ExoPlayer Asynchronously,
     * audioFile - name of asset wav file without path with out .wav
     */
    suspend fun playAsync(audioFile: Int) = exoPlayer.playAsync(audioFile = audioFile)

    // AUDIO TRACK
    suspend fun playSync(audioFile: Int) = audioPlayer.play(fileName = audioFile)

    /**
     * Release all classes
     */
    suspend fun release() {
        textToSpeech.release()
        speechRecognizer.release()
        audioPlayer.release()
        exoPlayer.release()
        throw CancellationException()
    }

}