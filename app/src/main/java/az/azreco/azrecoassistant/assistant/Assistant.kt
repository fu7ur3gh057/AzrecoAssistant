package az.azreco.azrecoassistant.assistant

import android.annotation.SuppressLint
import android.util.Log
import az.azreco.azrecoassistant.assistant.player.AudioPlayer
import az.azreco.azrecoassistant.assistant.azreco.SpeechRecognizer
import az.azreco.azrecoassistant.assistant.azreco.TextToSpeech
import az.azreco.azrecoassistant.assistant.azreco.TextToSpeechModel
import az.azreco.azrecoassistant.assistant.player.ExoPlayer
import az.azreco.azrecoassistant.constants.Audio
import kotlinx.coroutines.*
import java.io.ByteArrayOutputStream

class Assistant(
    private val speechRecognizer: SpeechRecognizer,
    private val textToSpeech: TextToSpeech,
    private val exoPlayer: ExoPlayer,
    private val audioPlayer: AudioPlayer
) {
    private val TAG = "DialogFlow"

    // SPEECH TO TEXT
    suspend fun listen(silence: Int = 3, keyWords: String) =
        speechRecognizer.listen(silence = silence, keyWords = keyWords)

    suspend fun speechRecognize(silence: Int = 3) =
        speechRecognizer.speechRecognize(silence = silence)

    suspend fun keywordSpotting(silence: Int = 5, keyWords: String) =
        speechRecognizer.keywordSpotting(silence = silence, keyWords = keyWords)


    // recursive function, works until KWS result won't be empty or counter >= limit
    suspend fun reKeywordSpotting(
        keyWords: String,
        limit: Int = 5,
        startLambda: () -> Unit,
        endLambda: suspend (String) -> Unit
    ) = coroutineScope {
        var counter = 0
        break_input@ do {
            counter += 1
            startLambda() // callback listening
            launch { playAsync(audioFile = Audio.signalStart) }
            val kWord = keywordSpotting(keyWords = keyWords, silence = 4)
            if (kWord.isNotEmpty()) {
                Log.d(TAG, "response is not Empty")
                endLambda(kWord)
            } else if (counter >= limit) {
                Log.d(TAG, "counter >= limit")
                playAsync(audioFile = Audio.signalStop)
                break@break_input
            } else if (kWord.isEmpty()) {
                Log.d(TAG, "response is Empty")
                playSync(audioFile = Audio.repeats)
            }
        } while (kWord.isEmpty())
    }

    // TEXT TO SPEECH
    /**
     * play single text by TextToSpeech
     */
    @SuppressLint("NewApi")
    fun speak(text: String, voiceId: String = "") =
        textToSpeech.speak(text = text, voiceId = voiceId)

    /**
     * play ByteArrayOutputStream, generated by TextToSpeech
     */
    @SuppressLint("NewApi")
    fun speakByteStream(baos: ByteArrayOutputStream) =
        textToSpeech.speakByteStream(baos = baos)

    /**
     * synthesize list of texts, returns list of generated ByteArrayOutputStream. for play use speakByteStream
     */
    @SuppressLint("NewApi")
    suspend fun synthesizeMultiple(
        texts: List<String>,
        voiceId: String = ""
    ): List<TextToSpeechModel> = textToSpeech.synthesizeMultiple(texts = texts, voiceId = voiceId)


    // EXO PLAYER
    /**
     * plays ExoPlayer Asynchronously,
     * audioFile - name of asset wav file without path with out .wav
     */
    suspend fun playAsync(audioFile: Int) = exoPlayer.playAsync(audioFile = audioFile)

    // AUDIO TRACK
    suspend fun playSync(audioFile: Int) = audioPlayer.play(fileName = audioFile)

    /**
     * Release all classes
     */
    suspend fun release() {
        textToSpeech.release()
        speechRecognizer.release()
        audioPlayer.release()
        exoPlayer.release()
        throw CancellationException()
    }

}